"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.update = void 0;
const child_process_1 = require("child_process");
const path_1 = require("path");
const fast_glob_1 = __importDefault(require("fast-glob"));
const fs_extra_1 = require("fs-extra");
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const deep_equal_1 = __importDefault(require("deep-equal"));
const semver_1 = __importDefault(require("semver"));
/** The name of the file in which we store a record of the changes we've made. */
const CHANGES_FILE = ".update-template-changes.json";
const update = async () => {
    const previousChanges = await loadPreviousChanges();
    const sourcePaths = findSourcePaths(process.argv.slice(2), previousChanges);
    const sources = [];
    /* Load sources */
    for (const sourcePath of sourcePaths) {
        try {
            const source = await findTemplateSource(sourcePath);
            if (!source) {
                throw new Error(`Couldn't load source: ${sourcePath}`);
            }
            sources.push(source);
        }
        catch (error) {
            console.error(ansi_colors_1.default.red.bold(`${sourcePath}: ${error.message}`));
            return 1;
        }
    }
    if (sources.length === 0) {
        throw new Error("Provide source repositories or paths");
    }
    const localPackageJson = await fs_extra_1.readJson(path_1.join(".", "package.json"));
    let workingPackageJson = { ...localPackageJson };
    const changes = {
        sources: {},
    };
    /* Remove any changes from templates no longer used */
    for (const sourceName of Object.keys(previousChanges.sources)) {
        if (!sources.find(s => s.name === sourceName)) {
            console.log(ansi_colors_1.default.red.bold(`${sourceName} (removing template)`));
            const previousSourceChanges = previousChanges.sources[sourceName];
            workingPackageJson = await undoPreviousTemplateChanges(workingPackageJson, sourceName, previousSourceChanges);
        }
    }
    for (const source of sources) {
        console.log(ansi_colors_1.default.bold.green(`${source.name}`));
        const config = source.config;
        const sourceChanges = {
            files: [],
            package: {},
        };
        changes.sources[source.name] = sourceChanges;
        const previousSourceChanges = previousChanges.sources[source.name];
        const previousFiles = previousSourceChanges ? previousSourceChanges.files : [];
        const files = (await fast_glob_1.default((config.files || []).map((glob) => `${source.path}/${glob}`))).map((file) => file.substring(source.path.length));
        for await (const file of files) {
            await fs_extra_1.ensureFile(path_1.join(".", file));
            const dest = path_1.join(".", file);
            console.log(ansi_colors_1.default.bold.blue(`  Copying: ${dest}`));
            await fs_extra_1.copyFile(path_1.join(".", source.path, file), dest);
            sourceChanges.files.push(file);
            const foundPreviousFile = previousFiles.indexOf(file);
            if (foundPreviousFile !== -1) {
                previousFiles.splice(foundPreviousFile, 1);
            }
        }
        /* Remove defunct files from template */
        if (previousFiles.length > 0) {
            for (const file of previousFiles) {
                const path = path_1.join(".", file);
                console.log(ansi_colors_1.default.blue.bold(`  Removing: ${path} (removed from template)`));
                await fs_extra_1.remove(path);
            }
        }
        const templatePackageJson = await fs_extra_1.readJson(path_1.join(".", source.path, "package.json"));
        workingPackageJson = applyPackageChanges(workingPackageJson, templatePackageJson, config, previousSourceChanges, sourceChanges);
        config.removeFiles = config.removeFiles || [];
        config.removeFiles = [...config.removeFiles, ".templaterc.json"];
        const filesToDelete = await fast_glob_1.default(config.removeFiles);
        for await (const file of filesToDelete) {
            const path = path_1.join(".", file);
            console.log(ansi_colors_1.default.blue.bold(`  Removing: ${path}`));
            await fs_extra_1.remove(path);
        }
        /* Remove any remaining changes, that are no longer made by templates */
        if (previousSourceChanges) {
            workingPackageJson = await undoPreviousTemplateChanges(workingPackageJson, source.name, previousSourceChanges);
        }
        if (source.temporary) {
            await fs_extra_1.remove(path_1.join(".", source.path));
        }
    }
    /* Update package.json */
    if (!deep_equal_1.default(localPackageJson, workingPackageJson)) {
        await fs_extra_1.writeFile(path_1.join(".", "package.json"), JSON.stringify(workingPackageJson, null, 2) + "\n");
    }
    /* Write changes file */
    await fs_extra_1.writeFile(path_1.join(".", CHANGES_FILE), JSON.stringify(changes, null, 2) + "\n");
    return 0;
};
exports.update = update;
function findSourcePaths(argv, previousChanges) {
    if (argv.length > 0) {
        return argv;
    }
    return Object.keys(previousChanges.sources);
}
async function cloneRepo(repoUrl) {
    // If this is running in a Github Actions workflow, we know the repo name
    let [owner, repo] = (process.env.GITHUB_REPOSITORY || "").split("/");
    if (owner && repo)
        if (repoUrl === `https://github.com/${owner}/${repo}`) {
            console.log("Skipping updating same repo");
            return undefined;
        }
    const tempDir = `tempDir_${Math.random().toString(32).split(".")[1]}`;
    child_process_1.execSync(`git clone ${repoUrl} ${tempDir}`);
    let config = {};
    try {
        config = await fs_extra_1.readJson(path_1.join(".", tempDir, ".templaterc.json"));
    }
    catch (error) {
        console.log(`${repoUrl}: .templaterc.json config file not found`);
    }
    return {
        name: repoUrl,
        path: tempDir,
        temporary: true,
        config,
    };
}
async function findTemplateSource(urlOrPath) {
    if (urlOrPath.includes("//")) {
        return cloneRepo(urlOrPath);
    }
    const statResult = await fs_extra_1.stat(urlOrPath);
    if (statResult.isDirectory()) {
        let config = {};
        try {
            config = await fs_extra_1.readJson(path_1.join(".", urlOrPath, ".templaterc.json"));
        }
        catch (error) {
            console.log(`${urlOrPath}: .templaterc.json config file not found`);
        }
        return {
            name: urlOrPath,
            path: urlOrPath,
            temporary: false,
            config,
        };
    }
}
function applyPackageChanges(target, template, config, previousChanges, changes) {
    const result = { ...target };
    function applyObjectChange(key, combine) {
        if (!template[key]) {
            console.log(ansi_colors_1.default.yellow.bold(`  Package is missing "${key}"`));
            return;
        }
        changes.package[key] = template[key];
        result[key] = combineRecords(target[key], template[key], combine);
        if (previousChanges && previousChanges.package[key] && template[key]) {
            for (const subkey of Object.keys(template[key])) {
                delete previousChanges.package[key][subkey];
            }
        }
        if (!deep_equal_1.default(target[key], result[key])) {
            console.log(ansi_colors_1.default.cyan.bold(`  Updated: ${key}`));
        }
    }
    if (config.package?.engines) {
        applyObjectChange("engines", combineChoosingLatest);
    }
    if (config.npmDependencies || config.package?.dependencies) {
        applyObjectChange("dependencies", combineChoosingLatest);
    }
    if (config.package?.devDependencies) {
        applyObjectChange("devDependencies", combineChoosingLatest);
    }
    if (config.package?.optionalDependencies) {
        applyObjectChange("optionalDependencies", combineChoosingLatest);
    }
    if (config.package?.peerDependencies) {
        applyObjectChange("peerDependencies", combineChoosingLatest);
    }
    if (config.npmScripts || config.package?.scripts) {
        applyObjectChange("scripts");
    }
    return result;
}
function undoPackageChanges(target, template) {
    const result = { ...target };
    function applyObjectChange(key) {
        result[key] = removeRecords(target[key], template[key]);
        if (!deep_equal_1.default(target[key], result[key])) {
            console.log(ansi_colors_1.default.red.bold(`  Updated: ${key}`));
        }
    }
    if (template.engines) {
        applyObjectChange("engines");
    }
    if (template.dependencies) {
        applyObjectChange("dependencies");
    }
    if (template.devDependencies) {
        applyObjectChange("devDependencies");
    }
    if (template.optionalDependencies) {
        applyObjectChange("optionalDependencies");
    }
    if (template.peerDependencies) {
        applyObjectChange("peerDependencies");
    }
    if (template.scripts) {
        applyObjectChange("scripts");
    }
    return result;
}
const DEFAULT_COMBINE = (existingValue, newValue) => newValue;
function combineChoosingLatest(existingValue, newValue) {
    if (!existingValue || existingValue === newValue) {
        return newValue;
    }
    if (!semver_1.default.validRange(existingValue) && semver_1.default.validRange(newValue)) {
        /* The existing value is not semver while the new is, so we'll retain the existing */
        return existingValue;
    }
    if (!semver_1.default.validRange(existingValue) || !semver_1.default.validRange(newValue)) {
        /* Neither are semver, so we'll use the new value as we cannot compare */
        return newValue;
    }
    const minExistingVersion = semver_1.default.minVersion(existingValue);
    const minNewVersion = semver_1.default.minVersion(newValue);
    if (!minExistingVersion || !minNewVersion) {
        /* Neither are semver, so we'll use the new value as we cannot compare */
        return newValue;
    }
    if (minNewVersion.compare(minExistingVersion) > 0) {
        return newValue;
    }
    else {
        return existingValue;
    }
}
function combineRecords(existing, template, combine = DEFAULT_COMBINE) {
    if (typeof existing !== "object") {
        if (typeof template !== "object") {
            return existing;
        }
        else {
            return template;
        }
    }
    else if (typeof template !== "object") {
        return existing;
    }
    const combined = {
        ...existing,
    };
    for (const key of Object.keys(template)) {
        combined[key] = combine(combined[key], template[key]);
    }
    const ordered = {};
    Object.keys(combined)
        .sort()
        .forEach((key) => (ordered[key] = combined[key]));
    return ordered;
}
function removeRecords(existing, template) {
    if (typeof existing !== "object" || typeof template !== "object") {
        return existing;
    }
    const combined = {
        ...existing,
    };
    for (const key of Object.keys(template)) {
        delete combined[key];
    }
    return combined;
}
async function loadPreviousChanges() {
    try {
        return await fs_extra_1.readJson(path_1.join(".", CHANGES_FILE));
    }
    catch (error) {
        /* Ignore no previous changes file */
        return {
            sources: {},
        };
    }
}
async function undoPreviousTemplateChanges(workingPackageJson, sourcePath, sourceChanges) {
    /* Remove any files from templates no longer used */
    for (const file of sourceChanges.files) {
        const path = path_1.join(".", file);
        console.log(ansi_colors_1.default.blue.bold(`  Removing: ${path}`));
        await fs_extra_1.remove(path);
    }
    return undoPackageChanges(workingPackageJson, sourceChanges.package);
}
//# sourceMappingURL=update.js.map